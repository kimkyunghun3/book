# 1주차 (~Chapter 4)

### 객체지향 속 협력하는 객체들의 공동체

객체지향에서 객체들은 각각 독립적으로 존재하지만 서로 협력하며 공동체를 이루고 있다.

예를 들어 커피를 주문하러 카페에 갔을 때에도 캐시어가 주문을 받고 그 캐시어가 바리스타에게 커피를 주문해달라고 하고 바리스타는 커피를 만든다. 이 과정에서도 협력하는 것을 볼 수 있다.

손님 - 캐시어 - 바리스타 

이렇게 객체들은 협력을 하고 있다. 손님 → 캐시어 요청하고 캐시어 → 바리스타 요청을 한다. 그럼 바리스타는 커피라는 것을 만들어서 바리스타 → 캐시어에 응답하고 캐시어 → 손님에 응답한다.

이처럼 각각 객체는 요청에 응답하는 책임을 가지고 있다.

객체의 상태는 객체의 행동에 따라 변하게 된다. 그러므로 객체에서 가장 중요한 것은 객체의 행동이다.

- 객체는 상태를 가지며 상태는 변경가능하다
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
    - 행동의 순서가 결과에 영향을 미친다.
- 객체는 어떤 상태에서도 유일하게 식별가능하다.

객체의 상태를 구성하는 모든 특징을 통들어 객체의 프로퍼티라고 한다.

프로퍼티는 정적이고 프로퍼티 값은 동적이다. 

예를 들어 객체가 사람이라고 하면 사람의 키, 위치 등은 정적이므로 프로퍼티고 프로퍼터의 값은 객체가 행동하면 변하게 된다. 문을 통과하면 위치가 다른 곳으로 바뀌는 등의 프로퍼티 값은 동적으로 바뀌게 된다.

### 상태 캡슐화

상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다.

이 말은 즉, 상태를 외부에 노출시키지 않으므로 자율성이 높아지는 것을 말할 수 있다. 그로인해 협력을 단순하고 유연하게 만들어 준다.

### 식별자

객체는 식별자로 다른 객체와 구별할 수 있는 유일한 것이다. 

만약 두 객체가 상태가 다르더라도 식별자가 같다면 두 객체를 같은 객체로 판단한다.

### 객체에는 타입과 추상화가 존재한다.

타입은 예를 들어 학교에서 1학년 2학년 3학년이 있다고 한다. 이를 각각 나이에 맞게 분류하여 각 학년을 구분한다. 이처럼 학년을 타입이라고 한다. 1학년은 1학년이라는 공통적인 특징을 가진 것을 의미하여 이를 타입으로 정의내린다. 그리하여 다른 타입과 구분할 수 있게 만든다. 이처럼 분류된 곳에서 하나의 객체를 인스턴스라고 한다.

추상화는 복잡성을 극복한다. 예전의 지하철 노선도는 보여짐이 아니라 실제 거리에 따라 작성되었다. 이는 현실적인 것을 반영하는 장점이 있지만 실제로 이를 보는 사람은 복잡하기 때문에 보는 것이 어렵다.

결국 타입으로 하는 것은 추상화와 같은 말일 수 있다. 타입을 이용하여 객체의 동적인 특성을 추상화할 수 있다. 

객체는 각각 역할이 존재하고 이에 따른 책임, 그리고 다른 객체와 협력을 이룬다.

예를 들어 판사 라는 객체는 재판을 하는 책임이 있고, 증인이라는 객체는 증언하는 책임이 존재한다. 

둘 사이는 협력이 필요하다. 판사가 특정 사람을 재판하기 위해서는 증언하는 증인이 필요하다. 그리하여 둘은 협력이 필요하다. 증인이 증언하는 것에 따라 판사는 다른 재판을 내릴 수 있다.

이처럼 객체는 혼자 활동하는 것보다 주위의 객체와 협력하며 책임을 수행한다. 그리하여 각 객체의 역할이 무엇인지에 대한 정확한 정의가 필요하다.

# 2주차 (~chapter 6)

### 책임과 메시지

훌륭한 객체지향에서는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력하는 체계다. 그들은 혼자 역할을 수행하는 것이 아니라 다른 객체와 협력하려고 한다. 협력을 하기 위해서는 메시지가 필요하다. 메시지 요청의 자율성에 따라 객체들의 자율성이 결정된다. 예를 들어, 판사가 증인에게 단순히 '증언하라' 라고 한다면 증인은 자신이 원하는 방식으로 증언을 하면 된다. 이 말은 즉, 증인 이라는 객체는 자율성을 가지고 행동할 수 있다. 
하지만 판사가 '문서를 통해 증언해라', '녹음을 통해 어제 한 일에 대해 묘사해라' 이런식으로 자세하지만 자율성을 해치는 요청을 한다면 이는 요청 받은 객체의 자율성을 낮추는 행동이다. 
이렇게 해버리면 자세해서 좋을 수도 있지만 객체지향의 세계에서는 이와 비슷한 상황에 대해 대처할 수 없다. 증언하라 라고 했다면 또 다른 상황에서도 이를 사용할 수 없지만 디테일한 요청을 하게 되면 다른 상황에서 재사용이 불가능하다. 

그러므로 **객체간의 자율성 확보**는 객체지향에서 매우 중요한 요소다!
하지만 너무 추상적이라면 이 또한 문제가 될 수 있다. 

예를 들어, 판사가 증인에게 '설명하라' 라고만 한다면 이는 어떤 것을 설명하라는지 파악하기 어렵다. 이처럼 너무 추상적인 요청은 또한 문제가 될 수 있다. 그러므로 추상적이면서 협력의 의도가 뚜렷하게 표현할 정도면 완벽하다!!

### 메시지 
그러므로 위와 같은 요청은 객체간의 '메시지'를 통해 이루어진다. 메시지는 객체지향에서 객제들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

### 메서드
메서드는 요청을 받은 객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 말한다. 
이는 요청하는 객체가 자세한 내용을 알 필요도 없으며 처리하는 객체 내부에서 원하는 방식으로 처리를 해도된다. 왜냐하면 요청하는 객체는 결과만 동일하면 되기 때문이다.

이 말은 '다형성' 이라고도 부른다. 동일한 메시지를 다르게 처리할 수 있는 것을 의미한다. 이를 통해 다양한 타입의 객체와 협력할 수 있게 도와준다.

그러므로 객체지향 설계를 할 때에는 먼저 어떤 메시지를 보낼 것인지를 선택하고 그다음에 책임을 질 객체를 선택하는 방향으로 하는 것이 옳다.

이로 인해 객체의 자율성을 만들고 캡슐화를 보장하며 각각 객체간의 결합도를 낮게 만들며 설계를 유연하게 만들 수 있다.

어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 결정한다.

인터페이스는 2가지로 나뉘는데, 외부에서 사용하는 공용 인터페이스 와 내부에서 사용하는 내부 인터페이스(**구현**)로 나뉜다.

### 공용 인터페이스
공용 인터페이스는 증인에게 '증언하라'는 문구가 다양하게 표현될 수 있는데 이를 공용 인터페이스를 통해 내부로는 동일한 것으로 판단하게 만든다. 

그래서 객체지향에서 자주 나오는 말이 인터페이스와 구현을 분리해야 한다고 한다.
외부에서 받아들이는 부분을 인터페이스라고 하는데 이것과 내부에서 처리하는 '구현'은 분리되어야 한다!

먼저 그전에 인터페이스를 구현하는 규칙에 대해 말해도록 하자!
- 추상적인 인터페이스
- 최소 인터페이스
- 구현과의 차이가 있다는 것을 인식

먼저 추상적으로 인터페이스를 구현해야 위에 말한 것들처럼 객체간의 자율성을 보장한다.

두 번째로는 최소 인터페이스로 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말라는 것이다. 이는 캡슐화를 통해 가능하게 만들 수 있다.

세 번쨰로는 구현과 차이를 두라는 말이 있다. 그 이유로는 항상 소프트웨어는 변하기 때문이다. 객체의 모든 것이 외부에 공개돼 있다면 작은 부분을 수정하더라고 파급효과가 객체 공동체의 모든 부분을 파고들 것이다. 

그러므로 각각을 자율적인 존재로 만들어서 변경에 대한 안전지대를 만들 필요가 있다. 이 말은 즉, 외부에 영향을 주지 않고도 메서드를 자유롭게 변경할 수 있도록 해야한다. 그러므로 적절한 구현을 선택하고 이를 인터페이스 뒤로 감추는 것이 객체의 자율성을 높이는 방버이다.

이를 위해서는 캡슐화를 통해 숨기는 방법을 자주 사용하곤 한다. 요청하는 객체가 모든 것에 대해 알 필요 없이 동작이나 원하는 값만 얻으면 되기 때문에 모든 정보를 접근하게 할 필요가 없기 때문이다.

# 객체 지도
먼저 설계는 기능 설계와 구조 설계가 있다.
기능 설계는 서비스를 구현하기 위한 설계 인 것이고 구조 설계는 소프트웨어인 제품을 어떻게 설계하면 좋을까에 대한 설계다.

책에 이런 인용문구가 있다.
> 훌륭한 기능이 훌륭한 소프트웨어를 만드는 충분조건이라고 한다면 훌륭한 구조는 훌륭한 소프트웨어를 만들기 위한 필요조건이다.

이 문구를 통해 훌륭한 구조가 얼마나 중요한 지에 대해 알 수 있다.

유저의 요구사항을 계속 바뀌고 소프트웨어도 바뀌게 된다. 이를 지속적으로 수정하게 되면 개발자는 모두 방전이 될 것이다. 그러므로 처음부터 변경 가능성이 있을 구조를 설계한다면 이를 대처하기 수월해진다.

이는 도메인 모델을 통해 주로 설계가 이루어진다.
필요한 객체가 무엇인지, 그리고 하는 역할을 판단하여 관계를 맺으면 이해하기 쉽고 확장성도 높다.

이를 유스케이스를 통해 보여준다면 조금 더 쉬운 구조 설계가 될 것이다. 그러므로 유스케이스를 해보는 것을 추천한다!!!

# 3주차 (~Chapter 7)

객체지향의 설계 안에 존재하는 상호 연관된 3가지 관점이 있다.
'개념 관점'에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관게를 표현한다. 이곳에서는 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 필요하다.
'명세 관점'은 사용자 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어를 말한다. 그리하여 소프트웨어 속 객체들의 책임에 초점을 맞추고 있다. 여기에서 프로그래머는 객체가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춘다. 그러므로 인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계하기 위한 기본적인 원칙이다.
'구현 관점'은 프로그래머가 실제 작업을 수행하는 코드와 연관이 있다. 객체들이 책임을 수행하는데 필요한 동작하는 코드를 작성하는 것이다. 여기에서는 객체의 책임을 '어떻게' 수행할 것인가에 초점을 맞추며 인터페이스를 구현한다.

이곳에서는 이를 커피전문점 예시를 들어서 설명하고 있다.

먼저 커피 전문점에는 바리스타, 메뉴판, 메뉴판 항목, 손님, 커피종류 가 필요하다.
그러므로 객체지향 관점에서 보면 커피 전문점이라는 도메인은 위와 같은 객체가 구성된 작은 세상이다.
이제 각각 객체간의 관계에 대해 살펴보도록 하자

먼저 메뉴판에는 메뉴항목이 포함되고 있으므로 포함관계를 통해 표현할 수 있으며 메뉴판을 보고 손님은 고르지만 각각의 관계는 서로 포함시키는 것이 아니므로 연관관계로 표현한다.
그리고 손님은 바리스타와 연관관계, 바리스타는 커피와 연관관게가 있다.

이제 이를 바탕으로 협력관련 설계가 필요하다.
손님은 커피를 주문하라는 메시지에 메뉴 이름을 포함한 메시지를 처리할 인스턴스다. 손님 객체는 커피를 주문할 책임을 할당 받게된다. 이제 입력한 메뉴 이름을 바탕으로 메뉴판에서 메뉴항목을 찾고 메뉴판에서는 메뉴 항목을 반환해주는 구조로 만들 수 있다.
또한 손님은 바리스타에게 위에서 받은 메뉴 항목을 보내주고 커피를 제조하라고 명령할 수 있다. 그럼 바리스타는 커피에 생성하라고 하고 이 반환되는 커피를 손님에게 리턴해주면 된다.
이런식으로 협력 설계가 가능해진다!
위 처럼 하나하나를 인터페이스라고 한다.

이를 바탕으로 코드를 짜면 구현하기 편하다

결론적으로 코드는 이 3가지 관점을 모두 제공해야한다.

먼저 개념관점에서 코드를 본다면 Customer, Menu, MenuItem, Barista, Coffee 클래스가 보인다.
명세 관점에서는 클래스의 인터페이스를 바라본다. 그래서 클래스의 메서드에 접근제어를 통해 접근가능하게할지 말지를 결정할 수 있다.
구현 관점에서는 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다. 그래서 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안된다.

다음으로 추상화 기법에 대해 설명하도록 하겠다.
아래와 같이 추상화 종류가 있다.
- 분류와 인스턴스화
- 일반화와 특수화
- 집합과 분해

분류와 인스턴스화로는 예시를 보면 자동차를 분류로 볼 수 있고 그 속에 벤츠, bmw 자동차 등등이 았다. 이를 분류로 보면 동일하게 자동차인 것이다.
일반화와 특수화 예시로는 먼저 일반화로는 운송수단으로 볼 수 있고 특수화로는 이 속에서 자동차, 자전거, 버스 등으로 나눌 수 있다. 또한 그 속에서도 자동차 안에 세단, suv 등등으로 나눌 수 있다.
집합과 분해로는 먼저 집합으로는 자동차로 볼 수 있고 분해는 자동차 안에 섀시, 차체, 엔진 등으로 분해할 수 있다.

객체 지향의 세계에서 개념을 가리키는 표준용어는 타입이라고 한다. 그러므로 분류한 객체들을 동일한 타입 또는 범주로 묶는 과정을 객체를 타입의 인스턴스라고 한다. 
그러므로 분류는 객체와 타입 간의 관계를 나타내는 것이고 어떤 객체가 타입의 정의에 부합할 경우 그 객체는 해당 타입으로 분류되며 자동으로 타입의 인스턴스가 된다고한다.

타입을 통해 객체를 분류하기 위해서서는 3가지 관점 정의가 필요하다.
- 심볼: 타입을 가리키는 간략한 이름이나 명칭
- 내연: 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
- 외연: 탕비에 속하는 모든 객체들의 집합

예시로 보자면 심볼은 자동차 라고 할 수 있고 내연은 '원동기를 동력원으로 해서 주행하는 사람이나 화물을 운반하는 기계'라고 할 수 있다. 또 외연은 세단, suv 등등이라고 할 수 있다.

타입에서도 슈퍼타입과 서브타입으로 나눌 수 있는데, 예를 보면 바로 이해할 수 있다.
슈퍼 타입은 큰 분류를 말하며 강아지, 고양이를 동물이라고 하는 것을 말한다.
서브타입은 슈처타입 속 분류된 것으로 강아지, 고양이 등으로 분류 할 수 있다.

이외에도 집합과 분해, 상속에 대한 이야기가 있는데 이는 위의 내용과 비슷하다고 판단하여 생략하도록한다.

이로써 책 한권 읽기를 끝나게 되었다. 이 책에서는 객체의 행동, 책임, 메시지를 중요하다고 보고있다. 이를 객체지향적 설계가 필요한 요소라고 보고 있으며 클래스를 생각하며 구현하는 것이 아니라 객체가 어떻게 해야하는지, 메시지는 무엇을 보내야하는지, 책임은 무엇을 갖고 있는지에 대해 고민해보고 구현하는 것이 옳은 방향이라고 제시하고 있다. 그러므로 객체지향적 설계를 할 때 객체를 초점맞춰서 구현할 필요가 있다고 느끼게 되었다. 가벼운 예시로 카드 게임, 판사-증인 등의 사례를 통해 쉽게 이해할 수 있어서 좋았고 객체지향에 대한 오해를 풀 수 있는 책이라고 생가한다.
자주 주기적으로 읽어주며 내것이 되도록 노력해야겠다!